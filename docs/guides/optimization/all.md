---
title: 性能优化的基本知识
---

# 性能优化的基本知识

## 一、引言

> 当打开浏览器，然后在地址栏输入一个网址之后，然后enter,发生了什么？
![20200407214919](https://raw.githubusercontent.com/yayxs/Pics/master/img/20200407214919.png)
### 1. 关键词

- 304缓存 (没有)
- HTTP报文（没有）
- 重绘、回流
- 同异步编程（没有）
- event loop（没有）
- 宏任务、微任务（没有）
- 进程、线程
- 栈内存（没有）
- 堆内存（没有）
- 图片懒加载（没有）
- 压缩（没有）
- 性能优化
- 浏览器存储（没有）
- 缓存机制（没有）

### 2. 说明

[**洋小洋同学web 前端高频面试题 不断完善更新**](https://top-fe-iqa.netlify.app/)

- 有些资料是参考网上资源，文末有链接
- 一个浏览器渲染引发的一系列问题
- 有不正确的欢迎指正

## 二、进程与线程

### 1. 进程

**程序的一次执行, 它占有一片独有的内存空间.是操作系统执行的基本单元。**

- 一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建
- 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
- 一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的

#### (1). 浏览器进程

- Browser进程:
  		浏览器的主进程,负责浏览器界面的显示,和各个页面的管理,
  		浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁
  		它有且只有一个!!!!!
- Renderer进程:
  		网页渲染进程,负责页面的渲染,可以有多个
  		当然渲染进程的数量不一定等于你开打网页的个数
- 各种插件进程
- GPU进程	
  	    移动设备的浏览器可能不太一样:
  	    Android不支持插件,所以就没有插件进程
  		GPU演化成了Browser进程的一个线程
  		Renderer进程演化成了操作系统的一个服务进程,它仍然是独立的

### 2 .线程

**是进程内的一个独立执行单元,是CPU调度的最小单元。程序运行的基本单元
	线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用**

> 由于jS是单线程的，就牵扯到事件循环、事件轮询、event loop （省略先）

## 三、HTTP 请求



### 3 .HTTPS和HTTP

## 四、HTTP 响应

## 五、浏览器渲染原理

![20200407221502](https://raw.githubusercontent.com/yayxs/Pics/master/img/20200407221502.png)

### 1. 浏览器功能

- 网络
  - 浏览器通过网络模块来下载各式各样的资源，例如html文本；javascript代码；样式表；图片；音视频文件等。
  - 网络部分本质上十分重要，因为它耗时长，而且需要安全访问互联网上的资源。
- 资源管理
  - 从网络下载，或者本地获取到的资源需要有高效的机制来管理它们。
  - 例如如何避免重复下载，资源如何缓存等

- 网页浏览
  - 资源转为可视化

- 等等……




### 3. 浏览器渲染机制

- 浏览器采用流式布局模型（`Flow Based Layout`）
- 浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了渲染树（`Render Tree`）。
- 有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
- 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，**但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一**



### 4. 浏览器渲染引擎

#### (1). 主要模块

- 解析器
  - 解释HTML文档的解析器
  - 作用：将HTML文本解释成DOM树
- CSS解析器
  - 它的作用是为DOM中的各个元素对象计算出样式信息
  - 为布局提供基础设施

- JavaScript引擎
  - 使用Javascript代码可以修改网页的内容，也能修改css的信息
  - javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果
- 布局（layout）回流
  - 在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来
  - 计算他们的大小位置等布局信息
  - 形成一个能表达这所有信息的内部表示模型
- 绘图模块
  - 使用图形库将布局计算后的各个网页的节点绘制成图像结果

#### (2). 渲染过程

[渲染树的构建、布局、及绘制中文](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)

![20200407223600](https://raw.githubusercontent.com/yayxs/Pics/master/img/20200407223600.png)


1.  遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）
2. 遇见 style/link 标记 调用解析器 处理 CSS 标记并构建 CSS样式树，即CSSOM
3. 遇见 script 标记 调用 javascript解析器 处理script标记，绑定事件、修改DOM树/CSS树 等
4. 将 DOM树 与 CSS树 合并成一个渲染树
5. 根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖图形库）
6. 将各个节点绘制到屏幕上。

### 5 .浏览器渲染阻塞

#### (1). CSS样式渲染阻塞

link引入的外部css**才能够产生阻塞**

#### (2). JS阻塞

## 六、性能优化

### 1. 减少HTTP的请求

### 2. 减少DOM的重绘与回流

#### (1). 重绘

由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如`outline`, `visibility`, `color`、`background-color`等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

#### (2). 回流

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。**有的大佬也习惯称之为重排**

##### 什么情况下浏览器会发生回流

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

#### (3). 浏览器优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你**获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值**。

主要包括以下属性或方法：

- `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

#### (4). 小结

**回流必定会发生重绘，重绘不一定会引发回流**    怎么最小化重绘重排？

1. ##### CSS

   - **使用 `transform` 替代 `top`**

   - **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者会引发回流（改变了布局

   - **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

   - **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

   - **避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

     ```
     <div>
       <a> <span></span> </a>
     </div>
     <style>
       span {
         color: red;
       }
       div > a > span {
         color: red;
       }
     </style>
     ```

     对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 `span` 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 `span` 标签，然后找到 `span` 标签上的 `a` 标签，最后再去找到 `div` 标签，然后给符合这种条件的 `span` 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写**过于具体**的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证**层级扁平**。

   - **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 `requestAnimationFrame`，详见[探讨 requestAnimationFrame](https://github.com/LuNaHaiJiao/blog/issues/30)。

   - **避免使用`CSS`表达式**，可能会引发回流。

   - **将频繁重绘或者回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change`、`video`、`iframe`等标签，浏览器会自动将该节点变为图层。

   - **CSS3 硬件加速（GPU加速）**，使用css3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

2. ##### JavaScript

   - **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
   - **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
   - **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。
   - **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



<!-- web性能可以通过以下几方面来优化
content方面
 1、减少HTTP请求：合并文件、CSS精灵、inline Image

2、减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名

3、减少DOM元素数量

Server方面
1、使用CDN

2、配置ETag

3、对组件使用Gzip压缩

Cookie方面
1、减小cookie大小

2、css方面

3、将样式表放到页面顶部

4、不使用CSS表达式

5、使用<link>不使用@import

Javascript方面
1、将脚本放到页面底部

2、将javascript和css从外部引入

3、压缩javascript和css

4、删除不需要的脚本

5、减少DOM访问

图片方面
1、优化图片：根据实际颜色需要选择色深、压缩

2、优化css精灵

3、不要在HTML中拉伸图片 -->

